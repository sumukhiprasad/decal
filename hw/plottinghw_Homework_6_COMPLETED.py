# -*- coding: utf-8 -*-
"""plottingHW.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10hg91HafkgsuSB-pULyaPHT6TQ6LkEe3

# Python DeCal HW 6: Plotting #
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import fsolve
import random

"""## Problem 1: Random Plots

This problem in an exercise in plotting random data. First you must generate three lists of random numbers, each 40 elements long with values ranging from 0 to 100. Then make two stacked vertical subplots. The top plot should plot one list of random data in orange and with a line width of 10 and another list in red and dashed. The bottom plot should be a scatter plot of the final list with magenta diamonds as the marker. In each case the x coordinate should be the position in the list.

<img src="q1_result.png" alt="q1 result image" style="height: 400px; width:650px;"/>



"""

import random
randomlist1 = [] # code below is generating a list of random numbers, 40 elements long with values ranging from 0 to 100
for i in range(0,41):
    n = random.randint(1,101)
    randomlist1.append(n)
print(randomlist1)

randomlist2 = [] # code below is generating a list of random numbers, 40 elements long with values ranging from 0 to 100
for i in range(0,41):
    n = random.randint(1,101)
    randomlist2.append(n)
print(randomlist2)

randomlist3 = [] # code below is generating a list of random numbers, 40 elements long with values ranging from 0 to 100
for i in range(0,41):
    n = random.randint(1,101)
    randomlist3.append(n)
print(randomlist3)

# orientation of subplots
fig, (ax1,ax2) = plt.subplots(2,1, figsize =(12,12)) # orientation of plot is what goes inside the parenthesis of subplots. So 1,2 says I will have 1 row with two columns. usually we would just have figure and not fig, (ax1, ax2) bc we usually don't have subplots

# plotting on the first subplot
ax1.plot(randomlist1, color = 'orange', linewidth = 10.0, label = 'list 1') # this plots the data on the ax1 subplot. The following is the documentation: plt.plot(X, Y, color="green", linewidth=1.0, linestyle="-")
ax1.plot(randomlist2, color = 'red', linewidth = 1, linestyle = '--', label = 'list 2') # this plots the data on the ax1 subplot. The following is the documentation: plt.plot(X, Y, color="green", linewidth=1.0, linestyle="-")
ax1.legend(loc = 'upper center') # we need to add labels to the corresponding y values (in previous two lines of code) that were plotted otherwise legend will not show up

# posting on the second subplot
ax2.plot(randomlist3, linewidth = 0, marker = 'D', markerfacecolor = 'magenta', markeredgewidth = 0) # this plots the data on the ax2 subplot, linewidth and markeredgewidth are set to 0 so they cannot be seen to match the example provided

# showing the plot with the new data
plt.show()

"""## Problem 2: van der Waals Gas

A Van der Waals gas is a model of gas particles that takes into account the interaction of the particles and the volume the particles take up. Like the ideal gas law, it relates pressure, volume, amount of gas and temperature. The equation is <br>
$\left(P +a\frac{n^2}{V^2}\right)(V-nb) = nRT \quad (1)$ <br>
Where $P$ is pressure, $V$ is volume, $T$ is temperature, $n$ is number of moles, $R$ is the ideal gas constant and $a,b$ are parameters. The value of $R$ is $0.083144 \frac{barL}{molK}$

Make a colormap plot of the temperature of one mole acetone for given volume and pressure. The pressure should vary between 1 and 10 bar and the volume should vary between 10 and 30 liters. For acetone $a = 16.02 \frac{barL^2}{mol^2}$ and $b = 0.1124 \frac{L}{mol}$. Make sure your axes labels have the correct values. Also make use of `vmin` and `vmax` to show detail in your color map and add a color bar to the map


"""

# pressure = np.linspace(1,10) # not needed since i created a meshgrid with the range of pressure values below
# volume = np.linspace(10,30) # not needed since i created a meshgrid with the range of volume values below
a = 16.02 # given
b = 0.1124 # given
R = 0.083144 # given
n = 1 # given
pressure, volume = np.meshgrid(np.linspace(1,10), np.linspace(10,30)) # The purpose of meshgrid is to create a rectangular grid out of an array of x values and an array of y values. The x and y arrays are both generated by linspace. Linspace creates a range of evenly spaced numbers over a specified interval - which we do for the range of x and y values that ultimately will create the meshgrid. I set the meshgrid equation equal to pressure, volume since those will be the parameter inputs into the function and it sets the dimensions of the array (if it was just x, it would make an array for the x values). If sparse = True, it would directly create the outline for the Euclidean grid (would create it's own matrix to fill with the axes values). Whereas sparse = False (default), it creates the coordinates for a grid of values (we'll have 1,1 and 1,2 and 1,3, etc.)
## how do i know when to set a function equal to x,y or - in this case - pressure,volume... what does it really mean? Does it initialize the generation of x,y coordinate points that make up the Euclidean grid? Basically, it tells the computer to set the dimensions of the axis with x axis first bc that's how python likes to do it
temperature_using_van_der_waals = ((pressure+(a*(n**2)/(volume**2)))*(volume-(n*b)))/(n*R) # I rearranged the given Van der Waals equation to solve for temperature.

plt.figure() # creates the figure object... this allows for the future addition of axis (for creation of subplots) and editing of the size of the figure object
plt.imshow(temperature_using_van_der_waals, cmap = 'twilight_shifted', vmin = 50, vmax = 4000, origin = 'lower') # the first argument (in this case is temperature_using_van_der_waals) shows the data of the image... So in this case, each coordinate's color will be matched to a corresponding temperature bc each cell is associated with (x,y,z) coordinates with z being temperature indicated by the range of colorbar colors... vmin and vmax normalizes all the colors and provides the range of depth colors for each coordinate point, and origin places the origin at the lower end of the plot
## imshow can take in image data as (m,n,RGB value) or can take in data that is the associated RGB value itself with the meshgrid already defined like we did in this case (since m and n values were already constructed from previous code, we just need corresponding color values that are dictated by the temperature eqn)
plt.colorbar() # shows a colorbar on the plot
plt.show() # shows the plot itself... Since the figure is an object, this initializes the plot coordinates showing up. Matplotlib is used in a terminal or scripts, plt.show() is a must. Matplotlib is used in a IPython shell or a notebook (ex: Kaggle), plt.show() is unnecessary.

"""## Problem 3: Stellar Interiors ##

This problem is adapted from Astro 160

In stars, there are two main methods of energy transport: radiative diffusion (where photons move energy through gas) and convection (where hot gas and colder gas exchange places). These procecess have associated temperature gradients, describing how the temperature changes as position (radius) inside the star changes. The star can only have one true temperature gradient which sometimes aligns with the radiative (radiative diffusion) or adiabatic (convection) temperature gradient. Convection only occurs when the true temperature gradient is aligned with the adiabatic temeprature gradient.

In the files `structure1_00001.txt`, `structure5_00001.txt`, `structure4_00001.txt`, there is data on the radius and temperature gradients for stars of three different masses: $0.5 M_\odot$, $1 M_\odot$ and $4 M_\odot$ respectively. Make a figure with three subplots, half for each star. On each subplots, plot the three temperature gradients, each in a different color and line style, and change the y axis to be logarithmic scale. On these plots indicate the convection zone(s) where the true temperature gradient is much closer to the adiabatic temeprature gradient than the radiative temeprature gradient.

The files contain a lot of data, but only some of it is useful to us. Namely the second (2) column contains the radius points of the measurement, the ninth (9) column contains the adiabatic temeprature gradient, the fourteenth (14) column contains the radiative temperature gradient and the fifteenth (15) columns contains the true temperature gradient.



"""

#file1 = pd.read_table('structure1_00001.txt', delimiter = " ")
#file5 = pd.read_table('structure5_00001.txt', delimiter = " ")
#file4 = pd.read_table('structure4_00001.txt', delimiter = " ", on_bad_lines = 'skip')

# reading in all the text files
file1 = np.transpose(np.loadtxt('structure1_00001.txt')) # need to transpose the text file because the text is automatically loaded with column values as rows. WIthout it being transposed, it tells me there are 196 rows and 36 columns which is the clue that I should be transposing. I just need to know what data I am working with and know what it should look like ideally.
file5 = np.transpose(np.loadtxt('structure5_00001.txt')) # need to transpose the text file because the text is automatically loaded with column values as rows.
file4 = np.transpose(np.loadtxt('structure4_00001.txt')) # need to transpose the text file because the text is automatically loaded with column values as rows.

# exporting all necessary columns for plotting from file 1
radius_file1 = file1[1] # this is reading in the radius of file 1 after it has been transposed
adiabatic_temperature_gradient_file1 = file1[10] # this is reading in the radius of file 1 after it has been transposed
radiative_temperature_gradient_file1 = file1[15]
true_temperature_gradient_file1 = file1[16]

# exporting all necessary columns for plotting from file 5
radius_file5 = file5[1]
adiabatic_temperature_gradient_file5 = file5[10]
radiative_temperature_gradient_file5 = file5[15]
true_temperature_gradient_file5 = file5[16]

# exporting all necessary columns for plotting from file 4
radius_file4 = file4[1]
adiabatic_temperature_gradient_file4 = file4[10]
radiative_temperature_gradient_file4 = file4[15]
true_temperature_gradient_file4 = file4[16]

#this is where I do the comparison to figure out wtf is going on
true_ad_file1 = np.abs(true_temperature_gradient_file1-adiabatic_temperature_gradient_file1)
true_rad_file1 = np.abs(true_temperature_gradient_file1-radiative_temperature_gradient_file1)
conv_zones_file1 = np.where(np.greater(true_rad_file1, true_ad_file1))[0]

true_ad_file5 = np.abs(true_temperature_gradient_file5-adiabatic_temperature_gradient_file5)
true_rad_file5 = np.abs(true_temperature_gradient_file5-radiative_temperature_gradient_file5)
conv_zones_file5 = np.where(np.greater(true_rad_file5, true_ad_file5))[0]

true_ad_file4 = np.abs(true_temperature_gradient_file4-adiabatic_temperature_gradient_file4)
true_rad_file4 = np.abs(true_temperature_gradient_file4-radiative_temperature_gradient_file4)
conv_zones_file4 = np.where(np.greater(true_rad_file4, true_ad_file4))[0]

fig, (ax1,ax2,ax3) = plt.subplots(3,1, figsize =(12,12)) # orientation of plot is what goes inside the parenthesis of subplots. So 1,2 says I will have 1 row with two columns. usually we would just have figure and not fig, (ax1, ax2) bc we usually don't have subplots

# plotting all types of temperature gradients for the first file (about stars with mass of 1M)
ax1.plot(radius_file1, adiabatic_temperature_gradient_file1, color = 'orange', linewidth = 1.5, label = 'list 1') # this plots the data on the ax1 subplot. The following is the documentation: plt.plot(X, Y, color="green", linewidth=1.0, linestyle="-"). If I don't put the x argument here, it assumes the x axis is the column number - it graphs temperature gradient with the position in the array.
ax1.plot(radius_file1, radiative_temperature_gradient_file1, color = 'red', linewidth = 1, linestyle = '--', label = 'list 5')
ax1.plot(radius_file1, true_temperature_gradient_file1, color = 'blue', linewidth = 1, linestyle = ':', label = 'list 5')
ax1.scatter(radius_file1[conv_zones_file1], true_temperature_gradient_file1[conv_zones_file1], marker='o', color='b')

ax2.plot(radius_file5, adiabatic_temperature_gradient_file5, color = 'orange', linewidth = 1.5, label = 'list 1') # this plots the data on the ax1 subplot. The following is the documentation: plt.plot(X, Y, color="green", linewidth=1.0, linestyle="-"). If I don't put the x argument here, it assumes the x axis is the column number - it graphs temperature gradient with the position in the array.
ax2.plot(radius_file5, radiative_temperature_gradient_file5, color = 'red', linewidth = 1, linestyle = '--', label = 'list 5')
ax2.plot(radius_file5, true_temperature_gradient_file5, color = 'blue', linewidth = 1, linestyle = ':', label = 'list 5')
ax2.scatter(radius_file5[conv_zones_file5], true_temperature_gradient_file5[conv_zones_file5], marker='o', color='b')

ax3.plot(radius_file4, adiabatic_temperature_gradient_file4, color = 'orange', linewidth = 1.5, label = 'list 1') # this plots the data on the ax1 subplot. The following is the documentation: plt.plot(X, Y, color="green", linewidth=1.0, linestyle="-"). If I don't put the x argument here, it assumes the x axis is the column number - it graphs temperature gradient with the position in the array.
ax3.plot(radius_file4, radiative_temperature_gradient_file4, color = 'red', linewidth = 1, linestyle = '--', label = 'list 5')
ax3.plot(radius_file4, true_temperature_gradient_file4, color = 'blue', linewidth = 1, linestyle = ':', label = 'list 5')
ax3.scatter(radius_file4[conv_zones_file4], true_temperature_gradient_file4[conv_zones_file4], marker='o', color='b')


#ax1.plt.axvline(x = .175, color = 'b', label = 'axvline - full height')

#ax1.legend(loc = 'upper center') # we need to add labels to the corresponding y values (in previous two lines of code) that were plotted otherwise legend will not show up
#ax3.plot(file4, color = 'blue', linewidth = 1, linestyle = '--', label = 'list 4')
ax1.set_yscale('log')
plt.xlabel("Star Radius")
ax1.legend(["Adiabatic Temperature Gradient", "Radiative Temperature Gradient", "True Temperature Gradient"])
ax2.set_yscale('log')
ax2.legend(["Adiabatic Temperature Gradient", "Radiative Temperature Gradient", "True Temperature Gradient"])
plt.xlabel("Star Radius")
ax3.set_yscale('log')
ax3.legend(["Adiabatic Temperature Gradient", "Radiative Temperature Gradient", "True Temperature Gradient"])
plt.xlabel("Star Radius")
plt.show()

# m=getSlope(x1,y1,x2,y2)
# b=y1-m*x1
# return b

#def findIntersection(fun1,fun2,x0):
# return fsolve(lambda x : fun1(x) - fun2(x),x0)

#result = findIntersection(true_temperature_gradient,adiabatic_temperature_gradient,0.0)
#x = numpy.linspace(-2,2,50)
#pylab.plot(x,numpy.sin(x),x,numpy.cos(x),result,numpy.sin(result),'ro')
#pylab.show()





#for i in radius_file1:
  # if np.abs(true_temperature_gradient_file1 - adiabatic_temperature_gradient_file1) > np.abs(true_temperature_gradient_file1 - radiative_temperature_gradient_file1):
  #  np.array[i]
#idx = np.argwhere(np.diff(np.sign(true_temperature_gradient_file1 - adiabatic_temperature_gradient_file1))).flatten()
#print(len(idx))

#PRACTICE

print(b[0:10])
print(n[0:10])

x = [3,4,3,7,8]
y = [5,4,2,9,3]

z = np.greater(x,y)
print(np.where(np.greater(x,y))[0])
print(z)

"""## Problem 4: Monte Carlo $\pi$ ##

Did you know that we can calculate the value of $\pi$ by generating random numbers? We first generate a whole bunch of random points in a 1x1 square with the corner at the origin. Then we see how many of the points are within a distance 1 of the origin. There points all fall in a quarter of a circle centered on the origin. Then using the relation <br>
$\frac{N_{in}}{N} \approx \frac{A_{qc}}{A}$ <br>
we can calculate $\pi$ from the ratio of the areas of a quarter circle and the square.

Calculate the value of $\pi$ using this procedure for N = 1e3, 1e4, 1e5, 1e6, and print your results. Also create a plot of these points for N = 1e4. The points within the quarter circle should all be one color and the points outside should also be a different color. Also please make sure your plot is a square and put the value of pi from that run on your plot as text.


"""

import random

N_in = 0
N = 10**4
for i in range(N):
    x = random.uniform(-1, 1)
    y = random.uniform(-1, 1)
    if x**2 + y**2 <= 1:
        N_in += 1
pi = 4 * N_in / N


# Generate random points and plot them
x = np.random.uniform(-1, 1, N)
y = np.random.uniform(-1, 1, N)
plt.plot(x, y, 'k.', markersize=1)

# Plot the quarter circle of radius 1
t = np.linspace(0, np.pi/2, 100)
xc = np.cos(t)
yc = np.sin(t)
plt.plot(xc, yc, 'r-', linewidth=2)

# Set the axis limits and labels
plt.xlim(-1, 1)
plt.ylim(-1, 1)
plt.xlabel('x')
plt.ylabel('y')

# Show the plot and the estimated value of pi
plt.title('Estimate of Pi: {:.4f}'.format(pi))
plt.show()

